# 5. Deploy Secure Confluent Platform

## Concepts

To secure Confluent Platform, think about it along the following dimensions:

- Authentication - establish who is accessing the system
- Network encryption  - protect data in transit
- Authorization - ensure that one can do only what they have been alllowed to do

In this exercise, you'll configure authentication and network encryption for the Confluent Platform and deploy to minikube.

## Deploy secure Confluent Platform

Remove the existing Confluent Platform install:

```
kubectl delete -f confluent-platform-minikube.yaml
kubectl get pods
```

You should see no Confluent Platform pods.

In order to have Confluent for Kubernetes provide auto-generated certificates,  you'll need to provide a Certificate Authority (CA). 

```
# Generate a CA
cd /home/ubuntu/code/cfk-workshop/dev
openssl genrsa -out ca-key.pem 2048
openssl req -new -key ca-key.pem -x509   -days 1000   -out ca.pem   -subj "/C=US/ST=CA/L=MountainView/O=Confluent/OU=Operator/CN=TestCA"
# Validate that the CA is valid
openssl x509 -in ca.pem -text -noout
```

Create a certificate from the files created above:

```
kubectl create secret tls ca-pair-sslcerts -n confluent   --cert=ca.pem   --key=ca-key.pem
```

You'll be using SASL/Plain mechanism for authentication. Clients use a username/password for authentication. The username/passwords are stored server-side in Kubernetes Secrets.

This file contains the username and password:

```
cd /home/ubuntu/code/cfk-workshop/dev

cat kafka-authentication-users.json
```

Create a Kubernetes secret from that file:

```
kubectl create secret generic credential --from-file=plain-users.json=kafka-authentication-users.json
```

Now that the CA and credentials are created, you can deploy the Confluent Platform deployment YAML that uses these secrets.

```
cat confluent-platform-secure-minikube.yaml
...
  tls:
    autoGeneratedCerts: true
  listeners:
    external:
      tls:
        enabled: true
      authentication:
        type: plain
        jaasConfig:
          secretRef: kafka-credentials
...

kubectl apply -f confluent-platform-secure-minikube.yaml
```

## Review the Confluent Platform status

```
# Check that the pods all come up healthy
kubectl get pods -w
```

Now with Kafka up and running, take a look at the Kafka listeners. 

Kafka listeners are the interfaces made available  for client applications and other Confluent components communicate with Kafka.

```
kubectl confluent cluster kafka listeners
COMPONENT  NAME   LISTENER-NAME  ACCESS    ADDRESS                                 TLS    AUTH   AUTHORIZATION
Kafka      kafka  internal       INTERNAL  kafka.confluent.svc.cluster.local:9071  false         
Kafka      kafka  replication    INTERNAL  kafka.confluent.svc.cluster.local:9072  false         
Kafka      kafka  external       INTERNAL  kafka.confluent.svc.cluster.local:9092  true   plain
```

## Update the apps to use security

Once the Confluent Platform is up, let's update the application deployments to use the secure channel to produce and consume.

The applications will connect to the Kafka listener on the endpoint `kafka.confluent.svc.cluster.local:9092`.

```
cd /home/ubuntu/code/cfk-workshop/apps

kubectl apply -f datagen-app-secure-secret.yaml

kubectl apply -f datagen-app-secure-deployment.yaml
```

The client app Kafka configurations specify how to connect to the secure Kafka listener:

```
cat datagen-app-secure-secret.yaml
...
 application.yaml: |
    spring:
      kafka:
        properties:
          bootstrap.servers: kafka.confluent.svc.cluster.local:9092
          sasl.mechanism: PLAIN
          sasl.jaas.config: "org.apache.kafka.common.security.plain.PlainLoginModule required username='dev-client' password='dev_client-secret';"
          security.protocol: SASL_SSL
          ssl.truststore.location: "/mnt/sslcerts/truststore.jks"
          ssl.truststore.password: "mystorepassword"
...
```

## Explore cluster and topics in Control Center

Confluent Control Center is a GUI interface to monitor Confluent Platform.

Check to see what the Kubernetes service endpoint is for Control Center.

```
kubectl get svc
...
controlcenter                ClusterIP      None             <none>        9021/TCP,7203/TCP,7777/TCP,7778/TCP                              44m
controlcenter-0-internal     ClusterIP      10.108.70.244    <none>        9021/TCP,7203/TCP,7777/TCP,7778/TCP                              44m
...
```

Start a port forwarding to allow access to the Control Center GUI.

```
kubectl port-forward --address 0.0.0.0 svc/controlcenter-0-internal 9021:9021
```

Login in to http://localhost:9021 to access Control Center.

You now should be in the Control Center app.